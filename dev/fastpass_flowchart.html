<!DOCTYPE html>
<html>
<head>
    <title>FastPass - Complete Code-Level Implementation Flowchart</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-style: italic;
        }
        .legend {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid #f57c00;
        }
        .legend h3 {
            margin-top: 0;
            color: #f57c00;
        }
        .legend ul {
            margin: 10px 0;
            list-style-type: none;
            padding: 0;
        }
        .legend li {
            padding: 5px 0;
            border-left: 3px solid transparent;
            padding-left: 10px;
        }
        .legend .business-logic { border-left-color: #f57c00; background-color: #fff8e1; }
        .legend .security { border-left-color: #e91e63; background-color: #fce4ec; }
        .legend .process { border-left-color: #4caf50; background-color: #e8f5e8; }
        .legend .decision { border-left-color: #ff9800; background-color: #fff3e0; }
        .mermaid {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 20px;
            overflow: auto;
            text-align: center;
        }
        
        /* Error path edge styling */
        .mermaid .edgePath.error-path path {
            stroke: #d32f2f !important;
            stroke-width: 3px !important;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background-color: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 5px;
            font-size: 14px;
        }
        button:hover {
            background-color: #005a85;
        }
        .zoom-info {
            font-size: 14px;
            color: #666;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FastPass - Complete Code-Level Implementation Flowchart</h1>
        <div class="subtitle">Every code block, edge case, and implementation detail mapped to flowchart elements</div>
        
        <div class="legend">
            <h3>üéØ Legend: Every Code Block Represented</h3>
            <ul>
                <li class="business-logic"><strong>Business Logic (Orange):</strong> Password handling, crypto operations, temp files</li>
                <li class="security">Security Operations (Pink): Path validation, access control, sanitization</li>
                <li class="process">Standard Processing (Green): I/O, parsing, validation, cleanup</li>
                <li class="decision">Decision Points (Orange): All branching logic and conditionals</li>
            </ul>
            <p><strong>Note:</strong> Each box represents a specific code block that will be labeled in the final implementation.</p>
        </div>
        
        <div class="controls">
            <button onclick="zoomIn()">üîç Zoom In</button>
            <button onclick="zoomOut()">üîç Zoom Out</button>
            <button onclick="resetZoom()">‚Üª Reset Zoom</button>
            <button onclick="downloadSVG()">üíæ Download SVG</button>
            <button onclick="printChart()">üñ®Ô∏è Print</button>
            <button onclick="forceRender()">üîÑ Force Render</button>
        </div>
        
        <div class="zoom-info">
            üí° Use Ctrl+Scroll to zoom. Each box maps to specific code blocks that will be labeled in implementation.
        </div>
        
        <div class="mermaid" id="diagram">
        </div>

    <script>
        // Mermaid content as JavaScript string to avoid HTML parsing issues
        const mermaidContent = `flowchart TD
    %% PROGRAM ENTRY POINT
    Start(["Program Startup\nFastPass application begins execution\nSystem checks if run directly (not imported)"]) --> Main
    
    %% MAIN FUNCTION EXCEPTION WRAPPER
    Main["Main Control Center\nSets up error handling for entire program\nPrepares to read user's command-line instructions"] --> A1a
    
    %% SECTION A: DETAILED CLI PARSING
    A1a["A1a: Load System Tools\nGather required system utilities\nCommand-line parsing, file handling, and type checking tools"] --> A1b
    
    A1b["A1b: Initialize Command Reader\nCreate a system to understand user commands\nSet up FastPass name and help description"] --> A1c
    
    A1c["A1c: Define Main Operation Choice\nUser must choose either encrypt OR decrypt\nCannot do both operations simultaneously"] --> A1d
    
    A1d["A1d: Set Up File Input Options\nUse -i/--input flag for space-delimited files\nRequire explicit file specification with quotes for spaced paths"] --> A1e
    
    A1e["A1e: Configure Password Options with Space Delimitation\nAccept space-delimited passwords with -p flag\nSupport password file and JSON stdin options"] --> A1f
    
    A1f["A1f: Set Output Location Options\nChoose where processed files should be saved\nDefault: replace original files in same location"] --> A1g
    
    A1g["A1g: Add Helper Features with Enhanced Logging\nTest mode, file verification, format listing\nDebug mode, file logging, report formats (text/JSON/CSV)"] --> A1h
    
    A1h["A1h: Read User's Commands\nProcess the command-line instructions user provided\nHandle cases where user asks for help or makes errors"] --> A1hCheck
    
    A1hCheck{"A1h_Check: Command Processing Result?\nDid user provide valid commands or ask for help?\nHandle different outcomes appropriately"}
    A1hCheck -->|"Invalid commands"| A1hError["A1h_Error: Invalid User Input\nShow error message explaining what went wrong\nExit program with error status"]
    A1hCheck -->|"Help requested"| A1hHelp["A1h_Help: Show Help Information\nDisplay usage instructions or version info\nExit normally after showing requested information"]
    A1hCheck -->|"No exception"| A1i
    
    A1i["A1i: Handle Information Requests\nCheck if user wants to see supported file formats\nShow list and exit if that's all they wanted"] --> A1iCheck
    
    A1iCheck{"A1i_Check: Information Request Mode?\nDid user ask to see supported formats only?\nOr do they want to actually process files?"}
    A1iCheck -->|"Show formats requested"| A1iList["A1i_List: Show Supported File Types\nModern Office: .docx, .xlsx, .pptx (experimental encryption)\nPDF: .pdf (full support)\nLegacy Office: .doc, .xls, .ppt (NOT SUPPORTED)"]
    A1iCheck -->|"Normal operation"| A2a
    
    %% ARGUMENT VALIDATION WITH EXPLICIT FILE PROCESSING
    A2a["A2a: Check Input Requirements\nUser must specify either files or folder to process\nCannot proceed without something to work on"] --> A2aCheck
    
    A2aCheck{"A2a_Check: Valid Input Method Provided?\nUser must choose files OR folder processing\nBoth options together would be confusing"}
    A2aCheck -->|"No input specified"| A2aError["A2a_Error: Nothing to Process\nTell user they must specify files or use folder mode\nExit with helpful error message"]
    A2aCheck -->|"Conflicting options"| A2aBothError["A2a_Both_Error: Conflicting Instructions\nUser specified both individual files AND folder processing\nExit with clarification about choosing one method"]
    A2aCheck -->|"Valid specification"| A2a1
    
    A2a1["A2a1: Validate Recursive Mode Usage\nCheck if recursive mode used with encrypt operation\nRecursive mode only allowed with decrypt/check-password"] --> A2a1Check
    
    A2a1Check{"A2a1_Check: Recursive Mode Valid?\nIs recursive mode used only with decrypt operations?\nPrevent dangerous bulk encryption"}
    A2a1Check -->|"Encrypt + recursive (dangerous)"| A2a1Error["A2a1_Error: Recursive Encryption Blocked\nRecursive mode only supported for decrypt operations\nSecurity restriction to prevent accidental bulk encryption"]
    A2a1Check -->|"Valid usage"| A2b
    
    A2b["A2b: Process Explicit File Paths\nHandle user-specified file paths directly\nExpand shortcuts like ~ for home directory"] --> A2bLoop
    
    A2bLoop["A2b_Loop: Process Each Specified File Path\nGo through user-provided file list\nHandle each file path one at a time"] --> A2bExpand
    
    A2bExpand["A2b_Expand: Convert Path to Full Address\nTransform user shortcuts into complete file locations\nResolve any symbolic links to actual files"] --> A2bCheck
    
    A2bCheck{"A2b_Check: Valid File Path?\nCan the system find and access this file location?\nHandle cases where paths don't exist or are invalid"}
    A2bCheck -->|"Path invalid"| A2bPathError["A2b_Path_Error: File Path Problem\nRecord which file path couldn't be found\nSave error details for final error report"]
    A2bCheck -->|"Path resolved successfully"| A2bNext
    
    A2bNext{"A2b_Next: More Files in List?\nAre there additional files to check?\nContinue with next file or move to next step"}
    A2bNext -->|"More files remaining"| A2bLoop
    A2bNext -->|"All files processed"| A2c
    
    A2c["A2c: Verify Folder for Batch Processing\nIf user chose folder mode, check the folder exists\nEnsure program can read files from that folder"] --> A2cCheck
    
    A2cCheck{"A2c_Check: Folder Accessible?\nIs the specified path actually a folder?\nDoes the program have permission to read it?"}
    A2cCheck -->|"Not a folder"| A2cDirError["A2c_Dir_Error: Path Is Not a Folder\nUser specified something that's not a folder\nExit with explanation of the problem"]
    A2cCheck -->|"Access denied"| A2cAccessError["A2c_Access_Error: Folder Permission Problem\nProgram doesn't have permission to read folder contents\nExit with permission error explanation"]
    A2cCheck -->|"Valid directory"| A2d
    
    A2d["A2d: Check Output Destination\nIf user specified where to save processed files\nVerify the output location is valid and writable"] --> A2dCheck
    
    A2dCheck{"A2d_Check: Output Location Usable?\nCan files be saved to the specified location?\nIs it a valid folder or can one be created?"}
    A2dCheck -->|"Location exists but wrong type"| A2dTypeError["A2d_Type_Error: Output Path Is File, Not Folder\nUser specified a file name where folder is needed\nExit with explanation of the problem"]
    A2dCheck -->|"Cannot create folder"| A2dCreateError["A2d_Create_Error: Unable to Create Output Folder\nSystem won't allow creation of new folder\nExit with permission or disk space error"]
    A2dCheck -->|"Valid output path"| A2e
    
    A2e["A2e: Remember User's Main Choice\nStore whether user wants to add or remove passwords\nThis choice affects all file processing operations"] --> A3a
    
    %% ENHANCED LOGGING SETUP WITH TTY DETECTION
    A3a["A3a: Configure Console and File Logging\nDetect TTY for appropriate log formatting\nSet up both console and optional file logging"] --> A3b
    
    A3b["A3b: Set Up TTY-Aware Progress Tracking\nTTY: Full timestamp format for console display\nNon-TTY: Simple format for file redirection"] --> A3c
    
    A3c["A3c: Initialize Multi-Handler Logger\nCreate console handler with TTY-specific formatting\nAdd file handler if --log-file specified"] --> A3d
    
    A3d["A3d: Handle Stdin Password Input\nCheck for 'stdin' in CLI passwords\nParse JSON password mapping from stdin if specified"] --> A3e
    
    A3e["A3e: Record Program Startup with Config\nLog FastPass startup with configuration sources\nRecord version, operation, and active config settings"] --> A4a
    
    %% CRYPTO TOOL DETECTION
    A4a["A4a: Load Encryption Tool Support\nImport libraries needed to work with different file types\nOffice documents and PDF handling capabilities"] --> A4b
    
    A4b["A4b: Check Office Document Tool\nTest if system can handle Microsoft Office files\nTry running Office encryption tool with timeout"] --> A4bCheck
    
    A4bCheck{"A4b_Check: Office Tool Working?\nDid the Office encryption tool respond properly?\nIs it installed and ready to use?"}
    A4bCheck -->|"Tool missing"| A4bError["A4b_Error: Office Tool Not Found\nMark Office document processing as unavailable\nAdd to list of missing required tools"]
    A4bCheck -->|"Tool not responding"| A4bTimeout["A4b_Timeout: Office Tool Hanging\nTool exists but not responding properly\nMark as unavailable due to system issues"]
    A4bCheck -->|"Tool working"| A4bSuccess["A4b_Success: Office Tool Ready\nOffice document processing available\nDecryption: full support, Encryption: experimental\nSystem can process .docx, .xlsx, .pptx files"]
    
    A4bError --> A4c
    A4bTimeout --> A4c
    A4bSuccess --> A4c
    
    A4c["A4c: Check PDF Processing Tool\nTest if system can handle PDF document encryption\nTry loading PDF processing library"] --> A4cCheck
    
    A4cCheck{"A4c_Check: PDF Tool Available?\nDid the PDF processing library load successfully?\nIs it properly installed and functional?"}
    A4cCheck -->|"Library missing"| A4cError["A4c_Error: PDF Tool Not Found\nMark PDF processing as unavailable\nAdd to list of missing required tools"]
    A4cCheck -->|"Library loaded"| A4cSuccess["A4c_Success: PDF Tool Ready\nPDF encryption/decryption is available\nSystem can process .pdf files"]
    
    A4cError --> A4d
    A4cSuccess --> A4d
    
    A4d["A4d: Verify All Tools Present\nCheck if all needed encryption tools are available\nBuild list of any missing critical tools"] --> A4dLoop
    
    A4dLoop["A4d_Loop: Iterate Through Tools\nCheck each tool in crypto_tools dict\nBuild list of missing required tools"] --> A4dCheck
    
    A4dCheck{"A4d_Check: Tool Available?\nif not crypto_tools.get(tool_name):\n  required_tools.append(tool_name)"}
    A4dCheck -->|"Tool missing"| A4dMissing["A4d_Missing: Add to Missing List\nrequired_tools.append(tool_name)\nTrack for error reporting"]
    A4dCheck -->|"Tool available"| A4dNext
    
    A4dMissing --> A4dNext
    A4dNext{"A4d_Next: More Tools to Check?\nContinue loop if more tools remain\nProcess all entries in crypto_tools"}
    A4dNext -->|"More tools"| A4dLoop
    A4dNext -->|"All tools checked"| A4e
    
    A4e["A4e: Validate All Tools Present\nif required_tools:\n  raise CryptoToolError(f'Missing: {required_tools}')"] --> A4eCheck
    
    A4eCheck{"A4e_Check: All Required Tools Available?\nlen(required_tools) == 0\nAll crypto tools are functional"}
    A4eCheck -->|"Tools missing"| A4eError["A4e_Error: Tools Missing\nerror_msg = f'Missing required tools: {required_tools}'\nlogger.error(error_msg); sys.exit(1)"]
    A4eCheck -->|"All tools available"| A5a
    
    %% FASTPASS APPLICATION INITIALIZATION
    A5a["A5a: Create FastPassApplication Class\nclass FastPassApplication:\n  def __init__(self, args, logger):"] --> A5b
    
    A5b["A5b: Initialize Instance Variables\nself.args = args; self.logger = logger\nself.operation_mode = args.operation"] --> A5c
    
    A5c["A5c: Initialize Tracking Lists\nself.temp_files_created = []\nself.processing_results = {}"] --> A5d
    
    A5d["A5d: Record Operation Start Time\nself.operation_start_time = datetime.now()\nFor performance metrics and timing"] --> A5e
    
    A5e["A5e: Initialize Password Manager\nself.password_manager = PasswordManager(\n  cli_passwords=args.cli_passwords or [])"] --> A5f
    
    A5f["A5f: Set Application State Flags\nself.ready_for_processing = True\nself.cleanup_required = True"] --> A5g
    
    A5g["A5g: Log Application Initialized\nself.logger.debug('FastPass application initialized')\nConfirm successful setup"] --> B1a
    
    %% SECTION B: DETAILED SECURITY & FILE VALIDATION
    B1a["B1a: Import Security Libraries\nimport os, pathlib, filetype\nimport stat, pwd, grp (for permissions)"] --> B1b
    
    B1b["B1b: Initialize File Collections\nvalidated_files = []\nsecurity_violations = []"] --> B1c
    
    B1c["B1c: Determine Files to Process\nif args.files: files_to_process = args.files\nelif args.recursive: files_to_process = collect_recursive()"] --> B1cCheck
    
    B1cCheck{"B1c_Check: File Collection Method?\nDetermine if processing individual files\nor collecting from recursive directory"}
    B1cCheck -->|"Individual files"| B1cFiles["B1c_Files: Use Individual Files\nfiles_to_process = args.files\nProcess provided file list"]
    B1cCheck -->|"Recursive directory"| B1cRecursive["B1c_Recursive: Collect Files Recursively\nfiles_to_process = collect_files_recursively(args.recursive)\nWalk directory tree for supported formats"]
    
    B1cFiles --> B1d
    B1cRecursive --> B1d
    
    B1d["B1d: Start File Processing Loop\nfor file_path in files_to_process:\n  process each file individually"] --> B1e
    
    B1e["B1e: Get Complete File Address\nConvert user path to full system path\nHandle home directory shortcuts and follow links"] --> B1eCheck
    
    B1eCheck{"B1e_Check: File Address Valid?\nWas the system able to find the complete file path?\nHandle cases where file location is unclear"}
    B1eCheck -->|"Address unclear"| B1eError["B1e_Error: Cannot Locate File\nSystem cannot determine exact file location\nAdd to list of files that couldn't be processed"]
    B1eCheck -->|"Resolution successful"| B1f
    
    B1f["B1f: Verify File Actually Exists\nCheck if the file is really there at that location\nRecord any files that can't be found"] --> B1fCheck
    
    B1fCheck{"B1f_Check: File Found and Accessible?\nDoes the file exist at the specified location?\nIs it actually a file (not a folder or link)?"}
    B1fCheck -->|"File not found"| B1fMissing["B1f_Missing: File Does Not Exist\nAdd to list of missing files\nRecord error for final report to user"]
    B1fCheck -->|"Not a file"| B1fType["B1f_Type: Path Points to Folder or Link\nUser specified something that's not a regular file\nSkip this entry as it cannot be encrypted"]
    B1fCheck -->|"File exists"| B2a
    
    %% ENHANCED SECURITY VALIDATION WITH ABSOLUTE PATH CHECKING
    B2a["B2a: Resolve Absolute Paths for Security\nUse Path.resolve() to get canonical paths\nEliminate symlinks and relative references"] --> B2b
    
    B2b["B2b: Validate Against Allowed Directories\nCheck if resolved path is within user home or current directory\nUse relative_to() method for containment verification"] --> B2bCheck
    
    B2bCheck{"B2b_Check: Path Within Security Boundaries?\nresolved_path.relative_to(allowed_dir) succeeds\nPath is contained within approved locations"}
    B2bCheck -->|"Outside allowed directories"| B2bDanger["B2b_Danger: Security Violation Detected\nFile path outside user home/current directory\nTerminate with sanitized security error"]
    B2bCheck -->|"Within security boundaries"| B2c
    
    B2c["B2c: Check Each Path Element\nExamine every folder and file name in the path\nEnsure each part follows security rules"] --> B2cLoop
    
    B2cLoop["B2c_Loop: Examine Path Elements One by One\nGo through each folder/file name in the path\nCheck each element for validity and security"] --> B2cCheck
    
    B2cCheck{"B2c_Check: Path Element Safe?\nIs this folder/file name safe and valid?\nCheck for illegal characters or reserved names"}
    B2cCheck -->|"Unsafe element"| B2cInvalid["B2c_Invalid: Unsafe Path Element Found\nThis folder/file name violates security rules\nFlag for administrator security review"]
    B2cCheck -->|"Valid component"| B2cNext
    
    B2cInvalid --> B2cNext
    B2cNext{"B2c_Next: More Path Elements to Check?\nAre there more folder/file names to examine?\nContinue until entire path is validated"}
    B2cNext -->|"More components"| B2cLoop
    B2cNext -->|"All components checked"| B2d
    
    B2d["B2d: Set Security Boundaries\nDefine which folders the program is allowed to access\nInclude user's home folder and current directory"] --> B2e
    
    B2e["B2e: Verify File Within Safe Zone\nCheck if file is inside allowed security boundaries\nPrevent access to system or other users' files"] --> B2eCheck
    
    B2eCheck{"B2e_Check: File in Safe Area?\nIs the file within approved security zones?\nBlock access to unauthorized system areas"}
    B2eCheck -->|"Outside safe zone"| B2eSecurity["B2e_Security: File Access Blocked\nFile is outside approved security boundaries\nTerminate processing to prevent security breach"]
    B2eCheck -->|"Within allowed boundaries"| B3a
    
    %% ENHANCED FILE FORMAT VALIDATION (MAGIC NUMBER PRIORITY)
    B3a["B3a: Load Magic Number Detection Tools\nPrepare filetype library for content-based detection\nPrioritize magic numbers over file extensions"] --> B3b
    
    B3b["B3b: Detect Format via Magic Numbers (Primary)\nUse filetype.guess() for authoritative format detection\nTrust file contents over extension claims"] --> B3bCheck
    
    B3bCheck{"B3b_Check: Magic Number Detection Successful?\nfiletype.guess() returned recognized MIME type\nFile signature matches supported format"}
    B3bCheck -->|"Magic number detected"| B3bSuccess["B3b_Success: Use Magic Number Result\nAuthoritative format from file contents\nCross-validate with extension (warn if mismatch)"]
    B3bCheck -->|"Magic number undetectable"| B3bFallback["B3b_Fallback: Use Extension Validation\nMagic number failed, try extension-based detection\nLog warning about undetectable format"]
    
    B3bSuccess --> B3c
    B3bFallback --> B3c
    
    B3c["B3c: Validate Extension Against Supported Formats\nCheck file extension against SUPPORTED_FORMATS dict\nApply as fallback when magic number unavailable"] --> B3d
    
    B3d["B3d: Verify FastPass Can Handle This Format\nCheck if this file type is supported by FastPass\nCompare against list of formats we can encrypt"] --> B3dCheck
    
    B3dCheck{"B3d_Check: File Type Supported?\nCan FastPass encrypt/decrypt this type of file?\nIs it in our list of supported formats?"}
    B3dCheck -->|"Format not supported"| B3dUnsupported["B3d_Unsupported: File Type Not Supported\nFastPass cannot handle this file format\nExit with explanation of supported formats"]
    B3dCheck -->|"Format supported"| B3e
    
    B3e["B3e: Double-Check File Type Consistency\nCompare file extension with actual file contents\nMake sure file isn't pretending to be something else"] --> B3eCheck
    
    B3eCheck{"B3e_Check: File Extension Matches Contents?\nDoes the file extension match what's actually inside?\nDetect files disguised as different formats"}
    B3eCheck -->|"Mismatch detected"| B3eMismatch["B3e_Mismatch: Format Mismatch\nlogger.warning(f'Extension {file_extension} != detected {mime_type}')\nFlag for manual review"]
    B3eCheck -->|"Formats match"| B4a
    
    B3eMismatch --> B4a
    
    %% FILE ACCESS VALIDATION
    B4a["B4a: Test File Reading Capability\nTry to open and read a small sample from the file\nVerify the program can actually access file contents"] --> B4aCheck
    
    B4aCheck{"B4a_Check: File Readable by Program?\nCan the program open and read from this file?\nCheck both permissions and file accessibility"}
    B4aCheck -->|"Cannot read file"| B4aRead["B4a_Read: File Reading Blocked\nProgram doesn't have permission to read this file\nExit with permission error explanation"]
    B4aCheck -->|"File readable"| B4b
    
    B4b["B4b: Check File Size Limits\nMeasure how big the file is\nEnsure it's not too large for processing"] --> B4bCheck
    
    B4bCheck{"B4b_Check: File Size Reasonable?\nIs the file smaller than 500MB and not empty?\nReject files that are too large or have no content"}
    B4bCheck -->|"File too big"| B4bLarge["B4b_Large: File Exceeds Size Limit\nFile is larger than 500MB processing limit\nExit with explanation of size restrictions"]
    B4bCheck -->|"File has no content"| B4bEmpty["B4b_Empty: File Contains No Data\nFile exists but has zero bytes of content\nSkip empty file as there's nothing to encrypt"]
    B4bCheck -->|"Size acceptable"| B4c
    
    B4c["B4c: Check File Modification Permission\nTest if program can modify files in this location\nVerify write access to the file's folder"] --> B4cCheck
    
    B4cCheck{"B4c_Check: Can Modify Files Here?\nDoes the program have permission to save changes?\nCan new files be created in this folder?"}
    B4cCheck -->|"Cannot modify files"| B4cWrite["B4c_Write: File Modification Blocked\nProgram lacks permission to save changes here\nExit with write permission error explanation"]
    B4cCheck -->|"Write access available"| B4d
    
    B4d["B4d: Test Output Directory Access\nif args.output_dir:\n  test write access to output location"] --> B4dCheck
    
    B4dCheck{"B4d_Check: Output Directory Writable?\nIf output_dir specified, ensure writable\nCreate directory if it doesn't exist"}
    B4dCheck -->|"Output not writable"| B4dOutput["B4d_Output: Output Directory Error\nlogger.error(f'Cannot write to output: {args.output_dir}')\nraise PermissionError()"]
    B4dCheck -->|"Output writable"| B5a
    
    %% ENCRYPTION STATUS DETECTION
    B5a["B5a: Determine File Type Handler\ncrypto_tool = SUPPORTED_FORMATS[file_extension]\nSelect appropriate detection method"] --> B5aCheck
    
    B5aCheck{"B5a_Check: Which Crypto Tool?\nBased on file extension, route to\nappropriate encryption detection method"}
    B5aCheck -->|"Office document"| B5aOffice["B5a_Office: Office Document Detection\nUse msoffcrypto.OfficeFile.is_encrypted()\nHandle Office-specific encryption"]
    B5aCheck -->|"PDF document"| B5aPDF["B5a_PDF: PDF Document Detection\nUse PyPDF2.PdfReader.is_encrypted\nHandle PDF-specific encryption"]
    
    B5aOffice --> B5b
    B5aPDF --> B5b
    
    B5b["B5b: Test Encryption Status\nwith open(resolved_path, 'rb') as f:\n  perform format-specific encryption test"] --> B5bCheck
    
    B5bCheck{"B5b_Check: Encryption Test Successful?\nDetection method completed without errors\nGot definitive encryption status"}
    B5bCheck -->|"Detection failed"| B5bFailed["B5b_Failed: Encryption Detection Failed\nlogger.warning(f'Cannot detect encryption: {resolved_path}')\nAssume unencrypted and proceed with caution"]
    B5bCheck -->|"Detection successful"| B5c
    
    B5bFailed --> B5c
    
    B5c["B5c: Store Encryption Status\nis_encrypted = detection_result\nAdd to file manifest for processing"] --> B6a
    
    %% BUILD FILE MANIFEST
    B6a["B6a: Create FileManifest Object\nmanifest_entry = FileManifest(\n  path=resolved_path, format=file_extension, ...)"] --> B6b
    
    B6b["B6b: Add File Metadata\nmanifest_entry.size = file_size\nmanifest_entry.is_encrypted = is_encrypted"] --> B6c
    
    B6c["B6c: Map to Crypto Tool\nmanifest_entry.crypto_tool = SUPPORTED_FORMATS[file_extension]\nStore handler reference"] --> B6d
    
    B6d["B6d: Add Security Flags\nmanifest_entry.security_checked = True\nmanifest_entry.access_verified = True"] --> B6e
    
    B6e["B6e: Add to Validated Files\nvalidated_files.append(manifest_entry)\nBuild complete processing list"] --> B6f
    
    B6f["B6f: Log File Validation\nlogger.debug(f'Validated: {resolved_path}')\nRecord successful validation"] --> B6g
    
    B6g{"B6g: More Files to Process?\nContinue loop if more files in\nfiles_to_process list remain"}
    B6g -->|"More files"| B1d
    B6g -->|"All files processed"| B6h
    
    B6h["B6h: Validate Final Results\nif not validated_files:\n  raise FileFormatError('No valid files found')"] --> B6hCheck
    
    B6hCheck{"B6h_Check: Any Files Successfully Validated?\nlen(validated_files) > 0\nAt least one file ready for processing"}
    B6hCheck -->|"No valid files"| B6hNoFiles["B6h_NoFiles: No Valid Files Error\nlogger.error('No valid files found to process')\nsys.exit(2)"]
    B6hCheck -->|"Files validated"| C1a
    
    %% SECTION C: CRYPTO TOOL SETUP (Detailed)
    C1a["C1a: Analyze Required Tools\nrequired_tools = set(manifest.crypto_tool\n  for manifest in validated_files)"] --> C1b
    
    C1b["C1b: Initialize Handler Dictionary\ncrypto_handlers = {}\nWill store instantiated crypto tool handlers"] --> C1c
    
    C1c["C1c: Check msoffcrypto Requirement\nif 'msoffcrypto' in required_tools:\n  need to initialize Office handler"] --> C1cCheck
    
    C1cCheck{"C1c_Check: msoffcrypto Needed?\nAny Office documents in file list\n(.docx, .xlsx, .pptx files present)"}
    C1cCheck -->|"msoffcrypto needed"| C1cOffice["C1c_Office: Initialize Office Handler\nfrom office_handler import OfficeDocumentHandler\ncrypto_handlers['msoffcrypto'] = OfficeDocumentHandler()"]
    C1cCheck -->|"msoffcrypto not needed"| C1d
    
    C1cOffice --> C1d
    
    C1d["C1d: Check PyPDF2 Requirement\nif 'PyPDF2' in required_tools:\n  need to initialize PDF handler"] --> C1dCheck
    
    C1dCheck{"C1d_Check: PyPDF2 Needed?\nAny PDF documents in file list\n(.pdf files present)"}
    C1dCheck -->|"PyPDF2 needed"| C1dPDF["C1d_PDF: Initialize PDF Handler\nfrom pdf_handler import PDFHandler\ncrypto_handlers['PyPDF2'] = PDFHandler()"]
    C1dCheck -->|"PyPDF2 not needed"| C2a
    
    C1dPDF --> C2a
    
    %% HANDLER CONFIGURATION
    C2a["C2a: Configure Office Handler\nif 'msoffcrypto' in crypto_handlers:\n  configure Office-specific settings"] --> C2aCheck
    
    C2aCheck{"C2a_Check: Office Handler Exists?\nHandler was initialized successfully\nReady for configuration"}
    C2aCheck -->|"Handler exists"| C2aConfig["C2a_Config: Configure Office Settings\nhandler.set_timeout(30)\nhandler.set_encryption_algorithm('AES-256')"]
    C2aCheck -->|"No handler"| C2b
    
    C2aConfig --> C2b
    
    C2b["C2b: Configure PDF Handler\nif 'PyPDF2' in crypto_handlers:\n  configure PDF-specific settings"] --> C2bCheck
    
    C2bCheck{"C2b_Check: PDF Handler Exists?\nHandler was initialized successfully\nReady for configuration"}
    C2bCheck -->|"Handler exists"| C2bConfig["C2b_Config: Configure PDF Settings\nhandler.set_encryption_method('AES-256')\nhandler.set_user_password_length(128)"]
    C2bCheck -->|"No handler"| C3a
    
    C2bConfig --> C3a
    
    %% PASSWORD MANAGEMENT SYSTEM (Detailed)
    C3a["C3a: Initialize PasswordManager Class\nclass PasswordManager:\n  def __init__(self, cli_passwords, password_list_file)"] --> C3b
    
    C3b["C3b: Remember User's Passwords\nStore passwords provided by user on command line\nAlso remember if user provided a password file"] --> C3c
    
    C3c["C3c: Prepare Password Storage\nSet up empty lists to hold all available passwords\nTrack which passwords work for which files"] --> C3d
    
    C3d["C3d: Load Passwords from File\nIf user provided a password file, read it now\nEach line in the file becomes a password to try"] --> C3dCheck
    
    C3dCheck{"C3d_Check: User Provided Password File?\nDid user specify a file containing passwords?\nOr are we only using command-line passwords?"}
    C3dCheck -->|"File provided"| C3dLoad["C3d_Load: Read Passwords from File\nOpen the password file and read each line\nEach line becomes a password to try on files"]
    C3dCheck -->|"No file specified"| C3e
    
    C3dLoad --> C3dLoadCheck
    
    C3dLoadCheck{"C3d_Load_Check: Password File Successfully Read?\nWas the program able to open and read the file?\nDoes it contain valid passwords to use?"}
    C3dLoadCheck -->|"File reading failed"| C3dLoadError["C3d_Load_Error: Cannot Read Password File\nFile is missing, corrupted, or access denied\nContinue using only command-line passwords"]
    C3dLoadCheck -->|"File read successfully"| C3dLoadSuccess["C3d_Load_Success: Passwords Successfully Loaded\nPassword file read and passwords are ready to use\nReport how many passwords were found"]
    
    C3dLoadError --> C3e
    C3dLoadSuccess --> C3e
    
    C3e["C3e: Set Up Password Priority System\nCreate system to try passwords in best order\nCommand-line passwords first, then file passwords"] --> C4a
    
    %% PASSWORD PRIORITY ALGORITHM (Detailed)
    C4a["C4a: Start Building Password List\nCreate empty list to hold passwords in order\nWill arrange by priority for best success rate"] --> C4b
    
    C4b["C4b: Add Command-Line Passwords First\nPut passwords user typed in command first\nThese have highest priority since user specified them"] --> C4c
    
    C4c["C4c: Add File Passwords Second\nAdd passwords from password file after command-line ones\nThese have lower priority but provide more options"] --> C4d
    
    C4d["C4d: Remove Duplicate Passwords\nEliminate passwords that appear multiple times\nKeep original order but avoid testing same password twice"] --> C4dLoop
    
    C4dLoop["C4d_Loop: Check Each Password for Duplicates\nGo through password list one by one\nSkip passwords we've already seen before"] --> C4dCheck
    
    C4dCheck{"C4d_Check: Have We Seen This Password Before?\nIs this password already in our final list?\nSkip if duplicate, keep if new"}
    C4dCheck -->|"Duplicate password"| C4dNext
    C4dCheck -->|"New password"| C4dAdd["C4d_Add: Add New Password to List\nMark this password as seen\nAdd it to our final password list"]
    
    C4dAdd --> C4dNext
    C4dNext{"C4d_Next: More Passwords to Check?\nAre there more passwords in our original list?\nContinue until all are checked for duplicates"}
    C4dNext -->|"More passwords"| C4dLoop
    C4dNext -->|"All processed"| C4e
    
    C4e["C4e: Finalize Password List\nReturn complete list ready for testing\nOrdered by priority with no duplicates"] --> C5a
    
    %% PASSWORD TESTING MECHANISM
    C5a["C5a: Set Up Password Testing System\nCreate system to try passwords against encrypted files\nTest each password until one works or all fail"] --> C5b
    
    C5b["C5b: Get Passwords to Try\nUse our priority system to get ordered password list\nCommand-line passwords first, then file passwords"] --> C5c
    
    C5c["C5c: Begin Trying Passwords\nGo through password list one by one\nTest each password to see if it unlocks the file"] --> C5d
    
    C5d["C5d: Try Current Password\nAttempt to unlock the file with this password\nUse appropriate tool for file type (Office/PDF)"] --> C5dCheck
    
    C5dCheck{"C5d_Check: Password Works?\nDid this password successfully unlock the file?\nCan we now read the file contents?"}
    C5dCheck -->|"Password unlocks file"| C5dSuccess["C5d_Success: Found Working Password\nThis password successfully unlocks the file\nRemember it for processing this file"]
    C5dCheck -->|"Password failed"| C5dNext
    
    C5dNext{"C5d_Next: More Passwords to Try?\nAre there more passwords in our list to test?\nKeep trying until we find one that works"}
    C5dNext -->|"More candidates"| C5c
    C5dNext -->|"All passwords failed"| C5dFailed["C5d_Failed: No Password Works\nTried all available passwords but none unlock this file\nCannot process this file - user needs correct password"]
    
    C5dSuccess --> D1a
    C5dFailed --> ErrorHandling
    
    %% SECTION D: ENHANCED FILE PROCESSING WITH CLEANUP TRACKING
    D1a["D1a: Initialize TempFileManager\nCreate TempFileManager for centralized cleanup\nRegister atexit handler for emergency cleanup"] --> D1b
    
    D1b["D1b: Create Secure Temp Directory\nUse SecureTempDirectory context manager\nAutomatic cleanup even on exceptions"] --> D1c
    
    D1c["D1c: Set Enhanced Secure Permissions\ntemp_dir.chmod(0o700) + subdirs with 0o700\nprocessing/, output/ subdirectories"] --> D1d
    
    D1d["D1d: Register Emergency Cleanup\natexit.register(emergency_cleanup_temp_directory)\nEnsure cleanup even on unexpected termination"] --> D1e
    
    D1e["D1e: Initialize Retry-Based Cleanup\nImplement exponential backoff for cleanup failures\nSecure file deletion with zero-overwrite"] --> D1f
    
    D1f["D1f: Track All Temp Resources\nTempFileManager tracks directories and files\nCentralized cleanup with error isolation"] --> D2a
    
    %% FILE PROCESSING PIPELINE
    D2a["D2a: Initialize Processing Results\nprocessing_results = ProcessingResults()\nsuccessful_files = []; failed_files = []"] --> D2b
    
    D2b["D2b: Start Main Processing Loop\nfor file_manifest in validated_files:\n  process each validated file"] --> D2c
    
    D2c["D2c: Get Crypto Handler\nhandler = crypto_handlers[file_manifest.crypto_tool]\nSelect appropriate handler for file type"] --> D2d
    
    D2d["D2d: Find Working Password\npassword = password_manager.find_working_password(\n  file_manifest.path, handler)"] --> D2dCheck
    
    D2dCheck{"D2d_Check: Password Found?\nfind_working_password() returned valid password\nFile can be processed"}
    D2dCheck -->|"No password found"| D2dNoPassword["D2d_NoPassword: Password Failure\nerror = FileProcessingError(file_manifest.path, 'No password')\nfailed_files.append(error)"]
    D2dCheck -->|"Password found"| D2e
    
    D2dNoPassword --> D2zNext
    
    D2e["D2e: Setup Temp File Paths\ntemp_input = temp_dir / 'processing' / f'input_{file_manifest.path.name}'\ntemp_output = temp_dir / 'output' / f'output_{file_manifest.path.name}'"] --> D2f
    
    D2f["D2f: Copy Input to Temp\nshutil.copy2(file_manifest.path, temp_input)\nPreserve metadata and timestamps"] --> D2fCheck
    
    D2fCheck{"D2f_Check: Copy Successful?\nFile copied without errors\ntemp_input exists and has correct size"}
    D2fCheck -->|"Copy failed"| D2fError["D2f_Error: Copy Failed\nerror = f'Failed to copy {file_manifest.path} to temp'\nfailed_files.append(FileProcessingError(...))"]
    D2fCheck -->|"Copy successful"| D2g
    
    D2fError --> D2zNext
    
    D2g["D2g: Determine Crypto Operation\nif args.operation == 'encrypt':\n  call handler.encrypt_file()"] --> D2gCheck
    
    D2gCheck{"D2g_Check: Which Operation?\nargs.operation is 'encrypt' or 'decrypt'\nRoute to appropriate handler method"}
    D2gCheck -->|"Encrypt operation"| D2gEncrypt["D2g_Encrypt: Perform Encryption\nhandler.encrypt_file(temp_input, temp_output, password)\nAdd password protection to file"]
    D2gCheck -->|"Decrypt operation"| D2gDecrypt["D2g_Decrypt: Perform Decryption\nhandler.decrypt_file(temp_input, temp_output, password)\nRemove password protection from file"]
    
    D2gEncrypt --> D2h
    D2gDecrypt --> D2h
    
    D2h["D2h: Crypto Operation Exception Handling\ntry: perform crypto operation\nexcept Exception as e: handle crypto errors"] --> D2hCheck
    
    D2hCheck{"D2h_Check: Crypto Operation Successful?\nNo exceptions raised during operation\ntemp_output file was created"}
    D2hCheck -->|"Operation failed"| D2hError["D2h_Error: Crypto Operation Failed\nlogger.error(f'Crypto operation failed: {e}')\nfailed_files.append(FileProcessingError(...))"]
    D2hCheck -->|"Operation successful"| D3a
    
    D2hError --> D2zNext
    
    %% OUTPUT VALIDATION (Detailed)
    D3a["D3a: Validate Output File Exists\nif not temp_output.exists():\n  raise ProcessingError('Output not created')"] --> D3aCheck
    
    D3aCheck{"D3a_Check: Output File Created?\ntemp_output.exists() and temp_output.is_file()\nCrypto operation produced valid output"}
    D3aCheck -->|"Output missing"| D3aError["D3a_Error: Output File Missing\nerror = 'Crypto operation did not create output file'\nfailed_files.append(FileProcessingError(...))"]
    D3aCheck -->|"Output exists"| D3b
    
    D3aError --> D2zNext
    
    D3b["D3b: Check Output File Size\noutput_size = temp_output.stat().st_size\nif output_size == 0: raise ProcessingError('Empty output')"] --> D3bCheck
    
    D3bCheck{"D3b_Check: Output Size Reasonable?\noutput_size > 0 and output_size < MAX_SIZE\nFile has content and isn't corrupted"}
    D3bCheck -->|"Empty or too large"| D3bSize["D3b_Size: Invalid Output Size\nerror = f'Invalid output size: {output_size} bytes'\nfailed_files.append(FileProcessingError(...))"]
    D3bCheck -->|"Size acceptable"| D3c
    
    D3bSize --> D2zNext
    
    D3c["D3c: Format-Specific Validation\nfile_format = file_manifest.format\nperform format-specific integrity checks"] --> D3cCheck
    
    D3cCheck{"D3c_Check: Which File Format?\nBased on file extension, perform\nappropriate format validation"}
    D3cCheck -->|"Office document"| D3cOffice["D3c_Office: Validate Office Document\ntry opening with appropriate Office library\nverify document structure integrity"]
    D3cCheck -->|"PDF document"| D3cPDF["D3c_PDF: Validate PDF Document\ntry opening with PyPDF2\nverify PDF structure and readability"]
    
    D3cOffice --> D3d
    D3cPDF --> D3d
    
    D3d["D3d: Validate Encryption Status Changed\nif operation == 'encrypt': verify file now encrypted\nif operation == 'decrypt': verify file no longer encrypted"] --> D3dCheck
    
    D3dCheck{"D3d_Check: Encryption Status Correct?\nPost-operation encryption status matches\nexpected result of encrypt/decrypt operation"}
    D3dCheck -->|"Status incorrect"| D3dStatus["D3d_Status: Encryption Status Error\nerror = f'Encryption status not changed correctly'\nfailed_files.append(FileProcessingError(...))"]
    D3dCheck -->|"Status correct"| D4a
    
    D3dStatus --> D2zNext
    
    %% ENHANCED FILE MOVEMENT WITH ERROR HANDLING
    D4a["D4a: Determine Final Output Path with Validation\nEnsure target directory exists (create if needed)\nHandle filename conflicts and permission checks"] --> D4aCheck
    
    D4aCheck{"D4a_Check: Output Directory Specified?\nargs.output_dir is not None\nUser wants files in specific directory"}
    D4aCheck -->|"Output dir specified"| D4aOutput["D4a_Output: Use Output Directory\nfinal_path = args.output_dir / file_manifest.path.name\nPreserve original filename"]
    D4aCheck -->|"In-place modification"| D4aInPlace["D4a_InPlace: In-Place Modification\nfinal_path = file_manifest.path\nReplace original file"]
    
    D4aOutput --> D4b
    D4aInPlace --> D4b
    
    D4b["D4b: Handle Filename Conflicts\nif final_path.exists():\n  handle existing file appropriately"] --> D4bCheck
    
    D4bCheck{"D4b_Check: Final Path Already Exists?\nfinal_path.exists() and not in-place mode\nNeed to handle filename conflict"}
    D4bCheck -->|"Conflict exists"| D4bConflict["D4b_Conflict: Resolve Filename Conflict\nif not in_place: generate unique name\nelse: prepare for overwrite"]
    D4bCheck -->|"No conflict"| D4c
    
    D4bConflict --> D4c
    
    D4c["D4c: Atomic Move with Error Handling\nEnsure target directory exists before move\nClean up temp file if move fails"] --> D4cCheck
    
    D4cCheck{"D4c_Check: Atomic Move Successful?\nshutil.move() completed without errors\nTemp file cleaned up on failure"}
    D4cCheck -->|"Move failed"| D4cError["D4c_Error: File Move Failed with Cleanup\nClean up temp_output file if move fails\nSanitize error message before logging"]
    D4cCheck -->|"Move successful"| D4d
    
    D4cError --> D2zNext
    
    D4d["D4d: Update File Permissions\nos.chmod(final_path, SECURE_FILE_PERMISSIONS)\nSet appropriate file permissions"] --> D4e
    
    D4e["D4e: Generate File Checksum\nimport hashlib\nchecksum = hashlib.sha256(final_path.read_bytes()).hexdigest()"] --> D4f
    
    D4f["D4f: Create Processing Result\nresult = FileProcessingResult(\n  original_path=file_manifest.path, final_path=final_path, ...)"] --> D4g
    
    D4g["D4g: Add to Successful Files\nsuccessful_files.append(result)\nlogger.info(f'Successfully processed: {file_manifest.path}')"] --> D2zNext
    
    %% LOOP CONTINUATION
    D2zNext{"D2z_Next: More Files to Process?\nContinue main processing loop\nProcess all files in validated_files"}
    D2zNext -->|"More files"| D2b
    D2zNext -->|"All files processed"| E1a
    
    %% SECTION E: ENHANCED CLEANUP WITH ERROR SANITIZATION
    E1a["E1a: Calculate Processing Metrics\ntotal_files, success_rate, processing_duration\nSanitize all error messages before reporting"] --> E1b
    
    E1b["E1b: Calculate Processing Duration\nend_time = datetime.now()\nduration = end_time - self.operation_start_time"] --> E1c
    
    E1c["E1c: Generate Performance Statistics\nfiles_per_second = total_files / duration.total_seconds()\naverage_file_size = sum(sizes) / len(sizes)"] --> E1d
    
    E1d["E1d: Categorize Processing Results\nresults_by_format = defaultdict(list)\nerrors_by_type = defaultdict(list)"] --> E1e
    
    E1e["E1e: Build Results Summary\nprocessing_summary = {\n  'total': total_files, 'successful': len(successful_files), ...}"] --> E2a
    
    %% ENHANCED CLEANUP WITH RETRY AND SECURE DELETION
    E2a["E2a: Start Enhanced Cleanup Process\nUse TempFileManager.cleanup_all()\nRetry logic with exponential backoff"] --> E2b
    
    E2b["E2b: Secure Temp Directory Cleanup\nOverwrite sensitive files with zeros\nMultiple cleanup attempts with retry logic"] --> E2bCheck
    
    E2bCheck{"E2b_Check: Enhanced Cleanup Successful?\nSecure deletion and retry cleanup completed\nAll temporary resources removed"}
    E2bCheck -->|"Cleanup failed after retries"| E2bError["E2b_Error: Cleanup Failed After Retries\nLog sanitized warning about cleanup failure\nDon't fail operation due to cleanup issues"]
    E2bCheck -->|"Cleanup successful"| E2c
    
    E2bError --> E2c
    
    E2c["E2c: Remove Individual Temp Files\nfor temp_file in self.temp_files_created:\n  try: temp_file.unlink()"] --> E2cLoop
    
    E2cLoop["E2c_Loop: Cleanup Individual Files\nfor temp_file_path in temp_files_created:\n  attempt to remove each tracked file"] --> E2cCheck
    
    E2cCheck{"E2c_Check: File Removal Successful?\ntemp_file.unlink() completed without error\nFile successfully deleted"}
    E2cCheck -->|"Removal failed"| E2cError["E2c_Error: File Removal Failed\nlogger.warning(f'Failed to remove: {temp_file_path}')\nContinue with remaining files"]
    E2cCheck -->|"Removal successful"| E2cNext
    
    E2cError --> E2cNext
    E2cNext{"E2c_Next: More Temp Files?\nContinue removing remaining tracked files\nClean up all temporary artifacts"}
    E2cNext -->|"More files"| E2cLoop
    E2cNext -->|"All files processed"| E2d
    
    E2d["E2d: Call Handler Cleanup\nfor handler in crypto_handlers.values():\n  handler.cleanup()"] --> E2e
    
    E2e["E2e: Verify Cleanup Completion\ncheck that all temp directories removed\nlog cleanup results"] --> E2f
    
    E2f["E2f: Calculate Disk Space Freed\nspace_freed = sum(temp_file_sizes)\nlogger.info(f'Cleanup freed {space_freed} bytes')"] --> E3a
    
    %% ENHANCED SENSITIVE DATA CLEARING WITH SANITIZATION
    E3a["E3a: Sanitize Error Messages\nApply sanitize_error_message() to all errors\nRemove paths, passwords, sensitive patterns"] --> E3aSanitize
    
    E3aSanitize["E3a_Sanitize: Pattern-Based Sanitization\nRemove password=<value>, IP addresses, email addresses\nReplace absolute paths with <path>/filename"] --> E3aLoop
    
    E3aLoop["E3a_Loop: Overwrite Password Memory\nfor password in all_password_references:\n  attempt to overwrite memory"] --> E3aCheck
    
    E3aCheck{"E3a_Check: Password Variable Found?\nLocate all variables containing passwords\nInclude CLI args, loaded lists, working passwords"}
    E3aCheck -->|"Password variable found"| E3aOverwrite["E3a_Overwrite: Overwrite Password\npassword_var = 'X' * len(password_var)\ndel password_var"]
    E3aCheck -->|"No more password vars"| E3b
    
    E3aOverwrite --> E3aNext
    E3aNext{"E3a_Next: More Password Variables?\nContinue clearing all password references\nEnsure no passwords remain in memory"}
    E3aNext -->|"More variables"| E3aLoop
    E3aNext -->|"All cleared"| E3b
    
    E3b["E3b: Delete Password Manager\ndel self.password_manager\ndel args.cli_passwords"] --> E3c
    
    E3c["E3c: Force Garbage Collection\nimport gc; gc.collect()\nForce Python garbage collection"] --> E3d
    
    E3d["E3d: Clear CLI Argument References\ndel args # if contains passwords\nClear any remaining password references"] --> E4a
    
    %% ENHANCED REPORT GENERATION WITH MULTIPLE FORMATS
    E4a["E4a: Generate Multi-Format Report\nSupport text, JSON, CSV report formats\nInclude sanitized error messages only"] --> E4aCheck
    
    E4aCheck{"E4a_Check: Report Format Selection\nargs.report_format determines output format\nGenerate appropriate structured report"}
    E4aCheck -->|"Text format"| E4aText["E4a_Text: Generate Human-Readable Report\nTraditional console output with visual indicators\nInclude troubleshooting guidance for failures"]
    E4aCheck -->|"JSON format"| E4aJSON["E4a_JSON: Generate Machine-Readable Report\nStructured JSON with timestamps and metrics\nInclude success rate and performance data"]
    E4aCheck -->|"CSV format"| E4aCSV["E4a_CSV: Generate CSV Report\nTabular format for spreadsheet analysis\nPer-file status with sanitized error messages"]
    
    E4aText --> E4b
    E4aJSON --> E4b
    E4aCSV --> E4b
    
    E4b["E4b: List Successful Files\nif successful_files:\n  for result in successful_files: print(f'SUCCESS: {result.path}')"] --> E4c
    
    E4c["E4c: List Failed Files\nif failed_files:\n  for error in failed_files: print(f'FAILED: {error.path}: {error.message}')"] --> E4d
    
    E4d["E4d: Add Performance Metrics\nprint(f'Total processing time: {duration}')\nprint(f'Average processing speed: {files_per_second} files/sec')"] --> E4e
    
    E4e["E4e: Add Troubleshooting Guidance\nif failed_files:\n  print('Troubleshooting suggestions:')"] --> E5a
    
    %% EXIT CODE DETERMINATION
    E5a["E5a: Analyze Results for Exit Code\nsuccess_count = len(successful_files)\nfailure_count = len(failed_files)"] --> E5b
    
    E5b["E5b: Apply Exit Code Logic\nif failure_count == 0 and success_count > 0:\n  exit_code = 0"] --> E5bCheck
    
    E5bCheck{"E5b_Check: Exit Code Determination\nBased on success/failure counts\nand error types encountered"}
    E5bCheck -->|"Perfect success"| E5bSuccess["E5b_Success: Exit Code 0\nexit_code = 0\nexit_reason = 'All operations successful'"]
    E5bCheck -->|"Mixed results"| E5bMixed["E5b_Mixed: Exit Code 1\nexit_code = 1\nexit_reason = 'Some operations failed'"]
    E5bCheck -->|"Complete failure"| E5bFailure["E5b_Failure: Exit Code 1\nexit_code = 1\nexit_reason = 'All operations failed'"]
    
    E5bSuccess --> E5c
    E5bMixed --> E5c
    E5bFailure --> E5c
    
    E5c["E5c: Log Final Status\nlogger.info(f'FastPass completed: {exit_reason}')\nlogger.info(f'Exit code: {exit_code}')"] --> E5d
    
    E5d["E5d: System Exit\nsys.exit(exit_code)\nTerminate program with appropriate code"] --> ProgramEnd
    
    %% ERROR HANDLING PATHS
    ErrorHandling["Error Handling: Exception Caught\nlogger.error(f'Unhandled exception: {e}')\nPerform emergency cleanup"] --> EmergencyCleanup
    
    EmergencyCleanup["Emergency Cleanup: Restore State\nif temp_dir.exists(): shutil.rmtree(temp_dir)\nClear sensitive data, exit with error"] --> ErrorExit
    
    ErrorExit["Error Exit: sys.exit(1)\nAbnormal termination\nReturn error code to shell"] --> ProgramEnd
    
    %% FINAL TERMINATION
    ProgramEnd(["Program Termination\nProcess ends, return to shell\nExit code indicates success/failure"])
    
    %% EXIT POINTS FROM VARIOUS ERROR CONDITIONS
    A1hError --> ProgramEnd
    A1hHelp --> ProgramEnd
    A1iList --> ProgramEnd
    A2aError --> ProgramEnd
    A2a1Error --> ProgramEnd
    A2aBothError --> ProgramEnd
    A2bPathError --> ProgramEnd
    A2cDirError --> ProgramEnd
    A2cAccessError --> ProgramEnd
    A2dTypeError --> ProgramEnd
    A2dCreateError --> ProgramEnd
    A4bError --> ProgramEnd
    A4bTimeout --> ProgramEnd
    A4cError --> ProgramEnd
    A4eError --> ProgramEnd
    B1eError --> ProgramEnd
    B1fMissing --> ProgramEnd
    B1fType --> ProgramEnd
    B2bDanger --> ProgramEnd
    B2cInvalid --> ProgramEnd
    B2eSecurity --> ProgramEnd
    B3dUnsupported --> ProgramEnd
    B3eMismatch --> ProgramEnd
    B4aRead --> ProgramEnd
    B4bLarge --> ProgramEnd
    B4bEmpty --> ProgramEnd
    B4cWrite --> ProgramEnd
    B4dOutput --> ProgramEnd
    B5bFailed --> ProgramEnd
    B6hNoFiles --> ProgramEnd
    C3dLoadError --> ProgramEnd
    D2dNoPassword --> ProgramEnd
    D2fError --> ProgramEnd
    D2hError --> ProgramEnd
    D3aError --> ProgramEnd
    D3bSize --> ProgramEnd
    D3dStatus --> ProgramEnd
    D4cError --> ProgramEnd
    
    %% STYLING
    classDef startBox fill:#e8f4fd,stroke:#1976d2,stroke-width:3px
    classDef processBox fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
    classDef businessLogic fill:#fff8e1,stroke:#f57c00,stroke-width:3px
    classDef decisionBox fill:#fff3e0,stroke:#ff9800,stroke-width:2px
    classDef exitBox fill:#ffebee,stroke:#f44336,stroke-width:2px
    classDef successBox fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
    classDef securityBox fill:#fce4ec,stroke:#e91e63,stroke-width:2px
    classDef errorBox fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px
    
    %% APPLY STYLES - BUSINESS LOGIC (Orange)
    class C3a,C3b,C3c,C3d,C3dLoad,C4a,C4b,C4c,C4d,C4dLoop,C4dAdd,C4e,C5a,C5b,C5c,C5d,C5dSuccess businessLogic
    class D1a,D1b,D1c,D1d,D1e,D1f,D2d,D2e,D2f,D2g,D2gEncrypt,D2gDecrypt,D2h businessLogic
    class D3c,D3cOffice,D3cPDF,D3d businessLogic
    class E3a,E3aSanitize,E3aLoop,E3aOverwrite,E3b,E3c,E3d businessLogic
    
    %% APPLY STYLES - SECURITY (Pink)
    class B2a,B2b,B2bCheck,B2bDanger,B2c,B2cLoop,B2cCheck,B2cInvalid,B2d,B2e,B2eCheck,B2eSecurity securityBox
    class B3bSuccess,B3bFallback securityBox
    class E3a,E3aSanitize,E3aLoop,E3aOverwrite,E3b,E3c,E3d securityBox
    
    %% APPLY STYLES - STANDARD PROCESSING (Green)
    class Start,Main,A1a,A1b,A1c,A1d,A1e,A1f,A1g,A1h,A1i,A2a,A2a1,A2b,A2bLoop,A2bExpand,A2c,A2d,A2e processBox
    class A3a,A3b,A3c,A3d,A3e,A3f,A4a,A4b,A4bSuccess,A4c,A4cSuccess,A4d,A4dLoop,A4e processBox
    class A5a,A5b,A5c,A5d,A5e,A5f,A5g processBox
    class B1a,B1b,B1c,B1cFiles,B1cRecursive,B1d,B1e,B1f,B3a,B3b,B3c,B3d,B3e processBox
    class B4a,B4b,B4c,B4d,B5a,B5aOffice,B5aPDF,B5b,B5c,B6a,B6b,B6c,B6d,B6e,B6f,B6g,B6h processBox
    class C1a,C1b,C1c,C1cOffice,C1d,C1dPDF,C2a,C2aConfig,C2b,C2bConfig processBox
    class D2a,D2b,D2c,D4a,D4aOutput,D4aInPlace,D4b,D4bConflict,D4c,D4d,D4e,D4f,D4g processBox
    class E1a,E1b,E1c,E1d,E1e,E2a,E2b,E2c,E2cLoop,E2d,E2e,E2f processBox
    class E4a,E4aText,E4aJSON,E4aCSV,E4b,E4c,E4d,E4e,E5a,E5b,E5bSuccess,E5bMixed,E5bFailure,E5c,E5d processBox
    
    %% APPLY STYLES - DECISION POINTS (Orange)
    class A1hCheck,A1iCheck,A2aCheck,A2a1Check,A2bCheck,A2bNext,A2cCheck,A2dCheck decisionBox
    class A4bCheck,A4cCheck,A4dCheck,A4dNext,A4eCheck decisionBox
    class B1eCheck,B1fCheck,B2bCheck,B2cCheck,B2cNext,B2eCheck,B3bCheck,B3dCheck,B3eCheck decisionBox
    class B4aCheck,B4bCheck,B4cCheck,B4dCheck,B5aCheck,B5bCheck,B6gCheck,B6hCheck decisionBox
    class C1cCheck,C1dCheck,C2aCheck,C2bCheck,C3dCheck,C3dLoadCheck decisionBox
    class C4dCheck,C4dNext,C5dCheck,C5dNext decisionBox
    class D2dCheck,D2fCheck,D2gCheck,D2hCheck,D2zNext decisionBox
    class D3aCheck,D3bCheck,D3cCheck,D3dCheck,D4aCheck,D4bCheck,D4cCheck decisionBox
    class E2bCheck,E2cCheck,E2cNext,E3aCheck,E3aNext,E4aCheck,E5bCheck decisionBox
    
    %% ERROR PATH LINK STYLING (Red edges leading to errors)
    %% Note: In Mermaid, edge styling should be done after all nodes and connections are defined
    %% This approach uses CSS classes to style error edges consistently
    
    %% APPLY STYLES - ERROR CONDITIONS (Red)
    class A1hError,A2aError,A2aBothError,A2a1Error,A2bPathError,A2cDirError,A2cAccessError errorBox
    class A2dTypeError,A2dCreateError,A4bError,A4bTimeout,A4cError,A4eError errorBox
    class B1eError,B1fMissing,B1fType,B2bDanger,B2cInvalid,B2eSecurity errorBox
    class B3dUnsupported,B3eMismatch,B4aRead,B4bLarge,B4bEmpty,B4cWrite,B4dOutput errorBox
    class B5bFailed,B6hNoFiles,C3dLoadError,C5dFailed errorBox
    class D2dNoPassword,D2fError,D2hError,D3aError,D3bSize,D3dStatus,D4cError errorBox
    class E2bError,E2cError,ErrorHandling,EmergencyCleanup,ErrorExit errorBox
    
    %% APPLY STYLES - SUCCESS/EXIT POINTS (Blue)
    class A1hHelp,A1iList,C3dLoadSuccess,C5dSuccess successBox
    class ProgramEnd successBox`;

        // Load the Mermaid content dynamically
        const diagramElement = document.getElementById('diagram');
        diagramElement.textContent = mermaidContent;
        diagramElement.className = 'mermaid';
    </script>

    <script>
        // Override Mermaid's text size limit
        if (window.mermaid && window.mermaid.mermaidAPI) {
            window.mermaid.mermaidAPI.maxTextSize = 900000;
        }
        
        // Add debug logging
        console.log('Mermaid version:', mermaid.version || 'unknown');
        console.log('Mermaid object:', mermaid);
        console.log('Initializing Mermaid with enhanced settings...');
        
        try {
            mermaid.initialize({ 
            startOnLoad: false,  // Changed to false since we're loading dynamically
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: false
            },
            securityLevel: 'loose',
            maxTextSize: 900000,  // Increase text size limit to 900KB
            suppressErrorRendering: false,
            logLevel: 'error',
            deterministicIds: true,
            deterministicIDSeed: 'fastpass-flowchart',
            // Additional config to handle large diagrams
            wrap: true,
            fontSize: 14,
            fontFamily: 'Arial, sans-serif',
            curve: 'basis'
        });
        
        console.log('Mermaid initialization completed');
        
        // Manually render the dynamically loaded content
        setTimeout(() => {
            try {
                mermaid.init(undefined, document.getElementById('diagram'));
                console.log('Dynamic Mermaid rendering completed');
                
                // Apply red styling to error paths
                setTimeout(() => {
                    styleErrorPaths();
                }, 200);
            } catch (renderError) {
                console.error('Dynamic rendering failed:', renderError);
                mermaid.parseError(renderError);
            }
        }, 100);
        
        } catch (initError) {
            console.error('Mermaid initialization failed:', initError);
            document.getElementById('diagram').innerHTML = `
                <div style="padding: 20px; border: 2px solid #f44336; background: #ffebee; border-radius: 4px;">
                    <h3 style="color: #d32f2f; margin-top: 0;">Mermaid Initialization Error</h3>
                    <p>Failed to initialize Mermaid library.</p>
                    <pre style="background: #f5f5f5; padding: 10px; border-radius: 4px;">${initError.message || initError.toString()}</pre>
                </div>
            `;
        }
        
        // Enhanced error handling with proper error stringification
        mermaid.parseError = function(err, hash) {
            console.error('Mermaid parse error:', err);
            console.error('Error details:', err.toString());
            console.error('Error message:', err.message);
            console.error('Error stack:', err.stack);
            
            // Properly stringify the error
            let errorDetails = '';
            if (err.message) {
                errorDetails = err.message;
            } else if (err.toString && err.toString() !== '[object Object]') {
                errorDetails = err.toString();
            } else {
                errorDetails = JSON.stringify(err, Object.getOwnPropertyNames(err), 2);
            }
            
            const diagramDiv = document.getElementById('diagram');
            diagramDiv.innerHTML = `
                <div style="padding: 20px; border: 2px solid #f44336; background: #ffebee; border-radius: 4px; margin: 20px 0;">
                    <h3 style="color: #d32f2f; margin-top: 0;">WARNING: Mermaid Rendering Error</h3>
                    <p>The flowchart encountered a rendering issue.</p>
                    <p><strong>Error Message:</strong></p>
                    <pre style="background: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; white-space: pre-wrap;">${errorDetails}</pre>
                    <p><strong>Workarounds:</strong></p>
                    <ul>
                        <li>Check browser console (F12) for detailed error messages</li>
                        <li>Try the 'Force Render' button with different settings</li>
                        <li>Click 'Load Pre-rendered SVG' for guaranteed display</li>
                        <li>View the source code directly in the HTML file</li>
                    </ul>
                    <p><em>Note: The diagram was successfully validated with mmdc CLI, so the content is correct.</em></p>
                </div>
            `;
        };
        
        // Add general error catching
        window.addEventListener('error', function(e) {
            if (e.message && e.message.includes('mermaid')) {
                console.error('Window error related to Mermaid:', e);
            }
        });
        
        // Function to style error paths with red edges
        function styleErrorPaths() {
            const errorNodes = [
                'A1hError', 'A2aError', 'A2aBothError', 'A2bPathError', 'A2cDirError', 'A2cAccessError',
                'A2dTypeError', 'A2dCreateError', 'A4bError', 'A4bTimeout', 'A4cError', 'A4eError',
                'B1eError', 'B1fMissing', 'B1fType', 'B2bDanger', 'B2cInvalid', 'B2eSecurity',
                'B3dUnsupported', 'B3eMismatch', 'B4aRead', 'B4bLarge', 'B4bEmpty', 'B4cWrite', 'B4dOutput',
                'B5bFailed', 'B6hNoFiles', 'C3dLoadError', 'C5dFailed',
                'D2dNoPassword', 'D2fError', 'D2hError', 'D3aError', 'D3bSize', 'D3dStatus', 'D4cError',
                'E2bError', 'E2cError', 'ErrorHandling', 'EmergencyCleanup', 'ErrorExit'
            ];
            
            try {
                const svg = document.querySelector('#diagram svg');
                if (!svg) return;
                
                // Find all edges (paths) in the SVG
                const edges = svg.querySelectorAll('.edgePath');
                
                edges.forEach(edge => {
                    const edgeId = edge.id || '';
                    // Check if this edge leads to an error node
                    errorNodes.forEach(errorNode => {
                        if (edgeId.includes(errorNode) || edge.classList.contains(errorNode)) {
                            const path = edge.querySelector('path');
                            if (path) {
                                path.style.stroke = '#d32f2f';
                                path.style.strokeWidth = '3px';
                            }
                        }
                    });
                });
                
                console.log('Error path styling applied');
            } catch (e) {
                console.warn('Could not apply error path styling:', e);
            }
        }

        let currentZoom = 1;
        const diagram = document.getElementById('diagram');

        function zoomIn() {
            currentZoom += 0.1;
            diagram.style.transform = `scale(${currentZoom})`;
            diagram.style.transformOrigin = 'top left';
        }

        function zoomOut() {
            currentZoom = Math.max(0.2, currentZoom - 0.1);
            diagram.style.transform = `scale(${currentZoom})`;
            diagram.style.transformOrigin = 'top left';
        }

        function resetZoom() {
            currentZoom = 1;
            diagram.style.transform = 'scale(1)';
        }

        function downloadSVG() {
            const svg = document.querySelector('#diagram svg');
            if (svg) {
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svg);
                const blob = new Blob([svgString], {type: 'image/svg+xml'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fastpass-complete-implementation-flowchart.svg';
                a.click();
                URL.revokeObjectURL(url);
            } else {
                // If SVG not available, download the raw mermaid code
                const mermaidCode = document.querySelector('.mermaid').textContent;
                const blob = new Blob([mermaidCode], {type: 'text/plain'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fastpass-flowchart-source.txt';
                a.click();
                URL.revokeObjectURL(url);
                alert('SVG not available. Downloaded raw Mermaid source code instead.');
            }
        }

        function printChart() {
            window.print();
        }

        function forceRender() {
            // Try to force render with even higher limits
            const diagram = document.getElementById('diagram');
            
            console.log('Force rendering with maximum settings...');
            
            // Clear and try again with maximum settings
            mermaid.initialize({
                startOnLoad: false,
                theme: 'default',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: false
                },
                securityLevel: 'loose',
                maxTextSize: 9999999,  // Very high limit
                suppressErrorRendering: false,  // Show errors for debugging
                logLevel: 'debug'  // More verbose logging
            });
            
            // Re-render
            const originalContent = diagram.innerHTML;
            diagram.innerHTML = originalContent;
            
            try {
                mermaid.init(undefined, diagram);
                console.log('Force render completed');
            } catch (e) {
                console.error('Force render failed:', e);
            }
        }
        
        
        diagram.addEventListener('wheel', function(e) {
            if (e.ctrlKey) {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }
        });
    </script>
</body>
</html>